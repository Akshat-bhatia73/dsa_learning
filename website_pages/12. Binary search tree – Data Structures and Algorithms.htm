<!DOCTYPE html>
<html lang="en" class="dark-theme"><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>12. Binary search tree – 
      Data Structures and Algorithms
    </title>
    <link rel="stylesheet" href="12.%20Binary%20search%20tree%20%E2%80%93%20Data%20Structures%20and%20Algorithms_files/fonts.css">
    <link rel="stylesheet" href="12.%20Binary%20search%20tree%20%E2%80%93%20Data%20Structures%20and%20Algorithms_files/style.css">
    <script>
      let activeTheme = localStorage.getItem("theme");
      if (activeTheme === null) {
        activeTheme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light";
      }
      document.documentElement.classList.toggle(
        "dark-theme",
        activeTheme === "dark"
      );
      const hideOtherSectionMenus = 1;
    </script>
    <script src="12.%20Binary%20search%20tree%20%E2%80%93%20Data%20Structures%20and%20Algorithms_files/navigation.js"></script>

    <link rel="stylesheet" href="12.%20Binary%20search%20tree%20%E2%80%93%20Data%20Structures%20and%20Algorithms_files/katex.min.css" integrity="sha384-vKruj+a13U8yHIkAyGgK1J3ArTLzrFGBbBc0tDp4ad/EyewESeXE/Iv67Aj8gKZ0" crossorigin="anonymous">
    <script defer="defer" src="12.%20Binary%20search%20tree%20%E2%80%93%20Data%20Structures%20and%20Algorithms_files/katex.min.js" integrity="sha384-PwRUT/YqbnEjkZO0zZxNqcxACrXe+j766U2amXcgMg5457rve2Y7I6ZJSm2A0mS4" crossorigin="anonymous"></script>
    <script defer="defer" src="12.%20Binary%20search%20tree%20%E2%80%93%20Data%20Structures%20and%20Algorithms_files/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous" onload="renderMathInElement(document.body, { delimiter: [{left:'\\(',right:'\\)',display:false},{left:'\\[',right:'\\]',display:true}] });"></script>
  </head>
  <body class="">
    <div class="menu-background" id="menu-background"></div>
    <button class="menu" id="menu" aria-expanded="false" aria-controls="side" aria-label="Menu">
      <svg viewBox="0 0 5 5" width="25" height="25">
        <rect width="5" height="1"></rect>
        <rect width="5" height="1" y="2"></rect>
        <rect width="5" height="1" y="4"></rect>
      </svg>
    </button>
    <div class="side" id="side">
      <header>
        <button class="theme" id="theme" title="Switch theme">
          <svg viewBox="0 0 10 10" width="25" height="25">
            <circle cx="5" cy="5" r="2.4"></circle>
            <circle cx="5" cy="1" r="0.8"></circle>
            <circle cx="9" cy="5" r="0.8"></circle>
            <circle cx="5" cy="9" r="0.8"></circle>
            <circle cx="1" cy="5" r="0.8"></circle>
            <circle cx="2.17" cy="2.17" r="0.8"></circle>
            <circle cx="7.83" cy="2.17" r="0.8"></circle>
            <circle cx="2.17" cy="7.83" r="0.8"></circle>
            <circle cx="7.83" cy="7.83" r="0.8"></circle>
          </svg>
        </button>
        <a class="header" href="https://tira.mooc.fi/spring-2025/">
          <h1>Data Structures and Algorithms</h1><h2>spring 2025</h2></a>
      </header>
      <nav>
        
        <ul>
          
          
            <li data-url="/">
  <a href="https://tira.mooc.fi/spring-2025/">Course description</a>
  
  
</li>
          
            <li data-url="/exercises">
  <a href="https://tira.mooc.fi/spring-2025/exercises">Exercises and lecture videos</a>
  
  
</li>
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
        </ul>
        
        
          
          
          <ul>
            
              <li data-url="/chap01/">
  <a href="https://tira.mooc.fi/spring-2025/chap01/">1. Introduction</a>
  
  
</li>
            
              <li data-url="/chap02/">
  <a href="https://tira.mooc.fi/spring-2025/chap02/">2. List</a>
  
  
</li>
            
              <li data-url="/chap03/">
  <a href="https://tira.mooc.fi/spring-2025/chap03/">3. Efficient algorithms</a>
  
  
</li>
            
              <li data-url="/chap04/">
  <a href="https://tira.mooc.fi/spring-2025/chap04/">4. Hashing</a>
  
  
</li>
            
              <li data-url="/chap05/">
  <a href="https://tira.mooc.fi/spring-2025/chap05/">5. Sorting</a>
  
  
</li>
            
              <li data-url="/chap06/">
  <a href="https://tira.mooc.fi/spring-2025/chap06/">6. Own data structures</a>
  
  
</li>
            
              <li data-url="/chap07/">
  <a href="https://tira.mooc.fi/spring-2025/chap07/">7. Trees and recursion</a>
  
  
</li>
            
              <li data-url="/chap08/">
  <a href="https://tira.mooc.fi/spring-2025/chap08/">8. Graph algorithms</a>
  
  
</li>
            
          </ul>
          
          
        
          
          
          <ul>
            
              <li data-url="/chap09/">
  <a href="https://tira.mooc.fi/spring-2025/chap09/">9. Search problems</a>
  
  
</li>
            
              <li data-url="/chap10/">
  <a href="https://tira.mooc.fi/spring-2025/chap10/">10. Dynamic programming</a>
  
  
</li>
            
              <li data-url="/chap11/">
  <a href="https://tira.mooc.fi/spring-2025/chap11/">11. More data structures</a>
  
  
</li>
            
              <li data-url="/chap12/">
  <a href="https://tira.mooc.fi/spring-2025/chap12/" class="current">12. Binary search tree</a>
  
  
    <ul>
      
        
          <li>
            <a href="https://tira.mooc.fi/spring-2025/chap12/#set-as-a-binary-tree" data-anchor="set-as-a-binary-tree">Set as a binary tree</a>
          </li>
        
      
        
          <li>
            <a href="https://tira.mooc.fi/spring-2025/chap12/#implementation-in-python" data-anchor="implementation-in-python">Implementation in Python</a>
          </li>
        
      
        
          <li>
            <a href="https://tira.mooc.fi/spring-2025/chap12/#balanced-trees" data-anchor="balanced-trees">Balanced trees</a>
          </li>
        
      
        
          <li>
            <a href="https://tira.mooc.fi/spring-2025/chap12/#example-hotel" data-anchor="example-hotel">Example: Hotel</a>
          </li>
        
      
        
          <li>
            <a href="https://tira.mooc.fi/spring-2025/chap12/#why-not-in-python" data-anchor="why-not-in-python">Why not in Python?</a>
          </li>
        
      
        
          <li>
            <a href="https://tira.mooc.fi/spring-2025/chap12/#other-programming-languages" data-anchor="other-programming-languages">Other programming languages</a>
          </li>
        
      
    </ul>
  
</li>
            
              <li data-url="/chap13/">
  <a href="https://tira.mooc.fi/spring-2025/chap13/">13. Directed graphs</a>
  
  
</li>
            
              <li data-url="/chap14/">
  <a href="https://tira.mooc.fi/spring-2025/chap14/">14. Shortest paths</a>
  
  
</li>
            
              <li data-url="/chap15/">
  <a href="https://tira.mooc.fi/spring-2025/chap15/">15. Components and spanning trees</a>
  
  
</li>
            
              <li data-url="/chap16/">
  <a href="https://tira.mooc.fi/spring-2025/chap16/">16. Maximum flow</a>
  
  
</li>
            
          </ul>
          
          
        
          
        
      </nav>
    </div>
    <main>
      <div class="awning" id="awning" aria-hidden="true">12. Binary search tree</div>
      <article data-url="/chap12/">
  <h1 id="12-binary-search-tree">12. Binary search tree</h1>

<p>Binary search tree is a data structure that maintains a set of 
elements. The basic operations are the same as with hashing: elements 
can be added, searched and removed efficiently.</p>

<p>Binary search tree differs from hashing in that it maintains the 
elements in order. Because of this, the smallest and the largest element
 in the set can be found efficiently, which is not possible with 
hashing.</p>

<p>The Python standard library does not have an implementation of a 
binary search tree, which makes using them a little bit more difficult 
in Python. In this chapter, we develop our <em>own</em> implementation of the binary search tree.</p>

<h2 id="set-as-a-binary-tree">Set as a binary tree</h2>

<p>A binary search tree is a binary tree, where each node stores one 
element of the set. For example, the following binary search tree 
corresponds to the set <span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mn>2</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>5</mn><mo separator="true">,</mo><mn>7</mn><mo separator="true">,</mo><mn>8</mn><mo separator="true">,</mo><mn>9</mn><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{2,3,5,7,8,9\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">{</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord">7</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord">8</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord">9</span><span class="mclose">}</span></span></span></span></span>:</p>

<p><img src="12.%20Binary%20search%20tree%20%E2%80%93%20Data%20Structures%20and%20Algorithms_files/bhp.png" alt=""></p>

<p>A binary search tree is organized so that for every node the elements
 in the left subtree are smaller than the element in the node, and 
symmetrically the elements in the right subtree are larger than the 
element in the node. For example in the tree above, the elements in the 
left subtree of the root are <span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">2</span></span></span></span></span> and <span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">3</span></span></span></span></span>, which are smaller than the root element <span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>5</mn></mrow><annotation encoding="application/x-tex">5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">5</span></span></span></span></span>. Similarly, the elements in the right subtree are <span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>7</mn></mrow><annotation encoding="application/x-tex">7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">7</span></span></span></span></span>, <span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>8</mn></mrow><annotation encoding="application/x-tex">8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">8</span></span></span></span></span> and <span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>9</mn></mrow><annotation encoding="application/x-tex">9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">9</span></span></span></span></span>, all of which are larger than the root element <span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>5</mn></mrow><annotation encoding="application/x-tex">5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">5</span></span></span></span></span>.</p>

<p>The element locations can be chosen freely in the binary tree as long
 as the above ordering condition is satisfied by every node. Thus the 
same set can be represented by different binary search trees. For 
example, the following two binary search trees both represent the set <span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>4</mn><mo separator="true">,</mo><mn>5</mn><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{1,2,3,4,5\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">{</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord">5</span><span class="mclose">}</span></span></span></span></span>:</p>

<p><img src="12.%20Binary%20search%20tree%20%E2%80%93%20Data%20Structures%20and%20Algorithms_files/bhp_1.png" alt=""></p>

<p>Let us next consider how set operations can be implemented using a binary search tree.</p>

<h3 id="finding-an-element">Finding an element</h3>

<p>When searching for an element, we start at the root. If the element 
in the node is smaller than the query element, the search continues in 
the right subtree. If the element in the node is larger than the query 
element, the search continues in the left subtree. This continues until 
we find the element, or until there is no child in the direction where 
the search should continue. The latter case means that the query element
 is not in the set.</p>

<p>For example, the search route for an element <span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>7</mn></mrow><annotation encoding="application/x-tex">7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">7</span></span></span></span></span> is illustrated in the following image:</p>

<p><img src="12.%20Binary%20search%20tree%20%E2%80%93%20Data%20Structures%20and%20Algorithms_files/bhp_2.png" alt=""></p>

<p>The search starts at the root, where the element is <span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>5</mn></mrow><annotation encoding="application/x-tex">5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">5</span></span></span></span></span>. This is smaller than the element <span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>7</mn></mrow><annotation encoding="application/x-tex">7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">7</span></span></span></span></span> and the search continues in the right child. The element there is <span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>8</mn></mrow><annotation encoding="application/x-tex">8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">8</span></span></span></span></span>, which is larger than the element <span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>7</mn></mrow><annotation encoding="application/x-tex">7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">7</span></span></span></span></span>. Thus the search continues to the left child, where the element <span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>7</mn></mrow><annotation encoding="application/x-tex">7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">7</span></span></span></span></span> is found.</p>

<h3 id="adding-an-element">Adding an element</h3>

<p>When adding an element, the first stage is to search for the element 
in the set. If the element is found, no addition is performed, because a
 set can contain an element only once. If the element is not found, a 
new node is inserted where the seach would have continued next, and the 
new element is stored in the new node.</p>

<p>For example, the following image illustrates the addition of an element <span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">4</span></span></span></span></span>:</p>

<p><img src="12.%20Binary%20search%20tree%20%E2%80%93%20Data%20Structures%20and%20Algorithms_files/bhp_3.png" alt=""></p>

<p>The search for the element <span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">4</span></span></span></span></span> starts at the root, where the element is <span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>5</mn></mrow><annotation encoding="application/x-tex">5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">5</span></span></span></span></span>. Next the search goes to the left child, where the element is <span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">3</span></span></span></span></span>. Here the search should continue to the right child but the node has no right child. This means that the element <span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">4</span></span></span></span></span> is not in the tree, and a new node storing the element <span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">4</span></span></span></span></span> is added as that missing right child. This ensures that a later search for the element <span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">4</span></span></span></span></span> will reach the node.</p>

<h3 id="smallest-element">Smallest element</h3>

<p>A search for the smallest element of the set starts at the root and 
always continues to the left child as long as possible. When going left 
is no more possible, the smallest element has been found.</p>

<h3 id="largest-element">Largest element</h3>

<p>A search for the largest element follows a similar procedure but always goes to the right instead of the left.</p>

<h3 id="successor">Successor</h3>

<p>The successor of an element <span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span></span> in the set is the smallest element that is larger than <span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span></span>. A search for the successor starts at the root, goes left when the element in the node is larger than <span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span></span>,
 and otherwise right. The search continues until there is nowhere to go.
 The desired element is among those encountered during the search, i.e.,
 the smallest of them that is larger than <span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span></span>.</p>

<h3 id="predecessor">Predecessor</h3>

<p>The predecessor of an element <span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span></span> in the set is the largest element that is smaller than <span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span></span>. A predecessor search is symmetric to a successor search: go right when the element is smaller than <span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span></span>, and left oterwise. The predecessor is the largest element smaller than <span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span></span> among the encountered elements.</p>

<h3 id="removing-an-element">Removing an element</h3>

<p>When removing an element, the first step is to find the node 
containing the element. The next step depends on the situation of the 
node in the tree. There are three cases:</p>

<ul>
  <li>The node has no children. Then the node can just be removed.</li>
  <li>The node has one child. Then the node can be removed and replaced by the its only child.</li>
  <li>The node has two children. Then find the successor of the element,
 and swap the elements in the two nodes. Then the new node of the 
element can be removed, because it has at most one child.</li>
</ul>

<p>The following image shows an example, where we want to remove the element <span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>5</mn></mrow><annotation encoding="application/x-tex">5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">5</span></span></span></span></span>. Since the node with the element <span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>5</mn></mrow><annotation encoding="application/x-tex">5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">5</span></span></span></span></span> has two children, the element <span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>5</mn></mrow><annotation encoding="application/x-tex">5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">5</span></span></span></span></span> is swapped with its successor <span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>7</mn></mrow><annotation encoding="application/x-tex">7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">7</span></span></span></span></span>. Then the new node of the element <span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>5</mn></mrow><annotation encoding="application/x-tex">5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">5</span></span></span></span></span> is easy to remove, because it has no children.</p>

<p><img src="12.%20Binary%20search%20tree%20%E2%80%93%20Data%20Structures%20and%20Algorithms_files/bhp_4.png" alt=""></p>

<p>Notice that when the node has two children, the successor node cannot
 have a left child and can always be removed easily. Also, the swap of 
the two elements does not violate the ordering conditions relative to 
any other elements.</p>

<h2 id="implementation-in-python">Implementation in Python</h2>

<p>Next we will begin developing an implementation of a binary search tree in Python. The goal here is a class <code class="language-plaintext highlighter-rouge">TreeSet</code> that can be used as follows:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">s</span> <span class="o">=</span> <span class="n">TreeSet</span><span class="p">()</span>

<span class="n">s</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">s</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">s</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="mi">2</span> <span class="ow">in</span> <span class="n">s</span><span class="p">)</span> <span class="c1"># True
</span><span class="k">print</span><span class="p">(</span><span class="mi">4</span> <span class="ow">in</span> <span class="n">s</span><span class="p">)</span> <span class="c1"># False
</span>
<span class="k">print</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="c1"># [1, 2, 3]
</span></code></pre></div></div>

<p>The method <code class="language-plaintext highlighter-rouge">add</code> adds an element to the set, the operator <code class="language-plaintext highlighter-rouge">in</code> reports if an element is in the set, and the string representation of the set is a list of its elements.</p>

<p>The following class <code class="language-plaintext highlighter-rouge">Node</code> stores the information related to a node in the tree:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Node</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="bp">None</span>
</code></pre></div></div>

<p>Each node contains three attributes: the element in the node (<code class="language-plaintext highlighter-rouge">value</code>) and references to the children (<code class="language-plaintext highlighter-rouge">left</code> and <code class="language-plaintext highlighter-rouge">right</code>).</p>

<p>The class <code class="language-plaintext highlighter-rouge">TreeSet</code> implements the binary search tree. Here is an initial template:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">TreeSet</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">root</span> <span class="o">=</span> <span class="bp">None</span>
</code></pre></div></div>

<p>The method <code class="language-plaintext highlighter-rouge">__init__</code> defines a reference to the root of the tree. Initially, there are no nodes, which is why <code class="language-plaintext highlighter-rouge">root</code> is <code class="language-plaintext highlighter-rouge">None</code>.</p>

<h3 id="adding-an-element-1">Adding an element</h3>

<p>The following method <code class="language-plaintext highlighter-rouge">add</code> adds an element to the set:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">.</span><span class="n">root</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">root</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">root</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">value</span> <span class="o">==</span> <span class="n">value</span><span class="p">:</span>
                <span class="k">return</span>
            <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">value</span> <span class="o">&gt;</span> <span class="n">value</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">:</span>
                    <span class="n">node</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                    <span class="k">return</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">:</span>
                    <span class="n">node</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                    <span class="k">return</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span>
</code></pre></div></div>

<p>If the tree is empty, the element is stored in a new node that 
becomes the root of the tree. Otherwise, the method performs a search 
starting from the root.</p>

<p>If a node containing the element is found, the method ends, because 
the element is already in the set. If the element in the node is larger 
than the element to be added, the search goes left, and if the element 
in the node is smaller than the element to be added, the search goes 
right. If there is no child where the search should continue, the 
element is stored in a new node that takes the place of the missing 
child, and the method ends.</p>

<h3 id="finding-an-element-1">Finding an element</h3>

<p>The following method <code class="language-plaintext highlighter-rouge">__contains__</code> checks if a given element is in the set. The method <code class="language-plaintext highlighter-rouge">__contains__</code> is called by the operator <code class="language-plaintext highlighter-rouge">in</code>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">def</span> <span class="nf">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">.</span><span class="n">root</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>

        <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">root</span>
        <span class="k">while</span> <span class="n">node</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">value</span> <span class="o">==</span> <span class="n">value</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">True</span>
            <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">value</span> <span class="o">&gt;</span> <span class="n">value</span><span class="p">:</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span>

        <span class="k">return</span> <span class="bp">False</span>
</code></pre></div></div>

<p>If the tree is empty, the element is not in the tree and the method returns <code class="language-plaintext highlighter-rouge">False</code>. Otherwise the method searches for the element similarly as with addition. If the element is found, the method returns <code class="language-plaintext highlighter-rouge">True</code>. If the element is not in the tree, the search will eventually go outside the tree (<code class="language-plaintext highlighter-rouge">node</code> becomes <code class="language-plaintext highlighter-rouge">None</code>), and the method ends and returns <code class="language-plaintext highlighter-rouge">False</code>.</p>

<h3 id="string-representation">String representation</h3>

<p>The following method <code class="language-plaintext highlighter-rouge">__repr__</code> constructs a string representation of the set, which contains the elements of the set as a list.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">items</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">traverse</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">root</span><span class="p">,</span> <span class="n">items</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">items</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">traverse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">items</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">,</span> <span class="n">items</span><span class="p">)</span>
        <span class="n">items</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">value</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">,</span> <span class="n">items</span><span class="p">)</span>
</code></pre></div></div>

<p>The method <code class="language-plaintext highlighter-rouge">__repr__</code> uses the method <code class="language-plaintext highlighter-rouge">traverse</code>
 that visits all nodes of the tree and adds their elements to the list. 
The traversal visits first all nodes in the left subtree, then adds the 
element in the node to the list, and then visits the nodes in the right 
subtree. This ensures that the elements are added to the list in the 
order of their value.</p>

<h3 id="other-operations">Other operations</h3>

<p>This implementation does not yet have methods for finding the 
smallest and the largest elements or for removing an element. The 
implementation of these methods is a part of the exercises for this 
week.</p>

<h2 id="balanced-trees">Balanced trees</h2>

<p>The operations on binary search trees follow a route from the root of
 the tree down towards the leafs of the tree. The efficiency of the tree
 depends on how long these routes can be. The length of the longest 
possible route is equal to the height of the tree <span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal">h</span></span></span></span></span>. Thus the time complexity of the operations can be stated to be <span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(h)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span style="margin-right: 0.0278em;" class="mord mathnormal">O</span><span class="mopen">(</span><span class="mord mathnormal">h</span><span class="mclose">)</span></span></span></span></span>.</p>

<p>An arbitrary binary search tree is not necessarily an efficient data 
structure, because the tree can be tall. For example, if we add <span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></span> elements into the tree in the order <span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">1,2,\dots,n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.8389em; vertical-align: -0.1944em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord mathnormal">n</span></span></span></span></span>, all element go into a single chain and the height of the tree is <span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.6667em; vertical-align: -0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">1</span></span></span></span></span>. Then the time complexity of the tree operations is <span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span style="margin-right: 0.0278em;" class="mord mathnormal">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span>.</p>

<p>However, it is possible to implement a binary search tree so that the
 elements are distributed evenly across the tree and the height of the 
tree is always of order <span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>log</mi><mo>⁡</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">\log n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mop">lo<span style="margin-right: 0.0139em;">g</span></span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord mathnormal">n</span></span></span></span></span>. Then the tree operations are efficient with time complexity <span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span style="margin-right: 0.0278em;" class="mord mathnormal">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right: 0.0139em;">g</span></span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span>. Such a binary search tree is called <em>balanced</em>.</p>

<p>A balanced binary search tree is implemented so that the height of the tree never grows too big. For example, an <a href="https://tira.mooc.fi/spring-2025/avlpuu">AVL tree</a>
 is a balanced binary search tree, where the heights of the left subtree
 and the right subtree of the same node cannot differ by more than <span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">1</span></span></span></span></span>. This condition ensures that the height of the tree is always of order <span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>log</mi><mo>⁡</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">\log n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mop">lo<span style="margin-right: 0.0139em;">g</span></span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord mathnormal">n</span></span></span></span></span>. To maintain that condition, the structure of the tree is modified with rotations when necessary.</p>

<h2 id="example-hotel">Example: Hotel</h2>

<p>The following is an example of a problem that can be solved efficiently using a binary search tree:</p>

<p class="note-title">Task</p>
<div class="note">

  <p>A hotel has <span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></span> rooms, each of which has a certain capacity (number of people). The hotel receives <span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span></span>
 groups of visitors. Your task is to process the groups in order from 
left to right, and assign to each group the smallest room with 
sufficient capacity for the whole group, or report that no suitable room
 is available.</p>

  <p>For example, suppose the room capacities are <span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>2</mn><mo separator="true">,</mo><mn>4</mn><mo separator="true">,</mo><mn>4</mn><mo separator="true">,</mo><mn>8</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[2,4,4,8]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">[</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord">8</span><span class="mclose">]</span></span></span></span></span> and the group sizes are <span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>4</mn><mo separator="true">,</mo><mn>6</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>5</mn><mo separator="true">,</mo><mn>2</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[4,6,2,5,2]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">[</span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord">2</span><span class="mclose">]</span></span></span></span></span>. Then the desired answer is <span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>4</mn><mo separator="true">,</mo><mn>8</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>0</mn><mo separator="true">,</mo><mn>4</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[4,8,2,0,4]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">[</span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord">8</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord">4</span><span class="mclose">]</span></span></span></span></span> (<span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">0</span></span></span></span></span> means that no room was assigned):</p>

  <ul>
    <li>The first group gets a room with capacity <span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">4</span></span></span></span></span>.</li>
    <li>The second group gets a room with capacity <span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>8</mn></mrow><annotation encoding="application/x-tex">8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">8</span></span></span></span></span>.</li>
    <li>The third group gets a room with capacity <span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">2</span></span></span></span></span>.</li>
    <li>The fourth group does not get a room.</li>
    <li>The fifth group gets a room with capacity <span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">4</span></span></span></span></span>.</li>
  </ul>

</div>

<p>Assume that we can use a class <code class="language-plaintext highlighter-rouge">TreeSet</code> with the following methods:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">add(x)</code>: adds an element <code class="language-plaintext highlighter-rouge">x</code> to the set</li>
  <li><code class="language-plaintext highlighter-rouge">next(x)</code>: returns the smallest element larger than <code class="language-plaintext highlighter-rouge">x</code> (or <code class="language-plaintext highlighter-rouge">None</code> if there is no such element)</li>
  <li><code class="language-plaintext highlighter-rouge">remove(x)</code>: removes the element <code class="language-plaintext highlighter-rouge">x</code> from the set</li>
</ul>

<p>The task can be solved using these methods as follows:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">find_rooms</span><span class="p">(</span><span class="n">sizes</span><span class="p">,</span> <span class="n">requests</span><span class="p">):</span>
    <span class="n">rooms</span> <span class="o">=</span> <span class="n">TreeSet</span><span class="p">()</span>
    <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">size</span> <span class="ow">in</span> <span class="n">sizes</span><span class="p">:</span>
        <span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">rooms</span><span class="p">.</span><span class="n">add</span><span class="p">((</span><span class="n">size</span><span class="p">,</span> <span class="n">counter</span><span class="p">))</span>
        
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">request</span> <span class="ow">in</span> <span class="n">requests</span><span class="p">:</span>
        <span class="n">room</span> <span class="o">=</span> <span class="n">rooms</span><span class="p">.</span><span class="nb">next</span><span class="p">((</span><span class="n">request</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">room</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">result</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">rooms</span><span class="p">.</span><span class="n">remove</span><span class="p">(</span><span class="n">room</span><span class="p">)</span>
            <span class="n">result</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">room</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            
    <span class="k">return</span> <span class="n">result</span>        
</code></pre></div></div>

<p>The function creates a set <code class="language-plaintext highlighter-rouge">rooms</code>
 and adds all available rooms to the set. Since multiple rooms can have 
the same capacity but the set cannot contain the same element multiple 
times, each room is represented as a pair, where the first part is the 
room capacity and the second is a unique room number. In the example 
case, the pairs <code class="language-plaintext highlighter-rouge">(2, 1)</code>, <code class="language-plaintext highlighter-rouge">(4, 2)</code>, <code class="language-plaintext highlighter-rouge">(4, 3)</code> and <code class="language-plaintext highlighter-rouge">(8, 4)</code> are added to the set.</p>

<p>Then the function goes through the groups and searches for a suitable room using the method <code class="language-plaintext highlighter-rouge">next</code>. The parameter for the method <code class="language-plaintext highlighter-rouge">next</code> is the pair <code class="language-plaintext highlighter-rouge">(request, 0)</code>, where <code class="language-plaintext highlighter-rouge">request</code> is the size of the group. Since <code class="language-plaintext highlighter-rouge">0</code> is smaller than any room number, the method finds the smallest room with a capacity at least <code class="language-plaintext highlighter-rouge">request</code>.</p>

<p>The time complexity of the function is <span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo>+</mo><mi>m</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \log n + m \log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span style="margin-right: 0.0278em;" class="mord mathnormal">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mop">lo<span style="margin-right: 0.0139em;">g</span></span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mop">lo<span style="margin-right: 0.0139em;">g</span></span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span> assuming that the binary search tree is balanced so that the tree operations take <span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span style="margin-right: 0.0278em;" class="mord mathnormal">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right: 0.0139em;">g</span></span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span> time.</p>

<h2 id="why-not-in-python">Why not in Python?</h2>

<p>Many programming languages offer an implementation of a binary search
 tree, but the Python standard library does not. Why is this?</p>

<p>The likely explanation is that the Python developers did not consider
 the binary search tree to be so frequently needed that it should be in 
the standard library. Python relies on hashing-based data structures (<code class="language-plaintext highlighter-rouge">set</code> and <code class="language-plaintext highlighter-rouge">dict</code>), which are sufficient for most purposes.</p>

<p>Indeed, hashing as well as sorting and a heap are alternatives to a 
binary search tree. In many tasks, one of the efficient solutions is to 
use a binary search tree, but often there are other efficient solutions 
without binary search trees.</p>

<p>If a binary search tree is needed, there are many implementations 
outside the standard library. Using one of these might be a better 
alternative than implementing your own binary search tree.</p>

<h2 id="other-programming-languages">Other programming languages</h2>

<p>In C++, the data structures <code class="language-plaintext highlighter-rouge">std::set</code> and <code class="language-plaintext highlighter-rouge">std::map</code>
 implement a set and a dictionary using a binary search tree. For 
example, the following code creates a set, adds elements with the 
function <code class="language-plaintext highlighter-rouge">insert</code> and searches for a successor using the function <code class="language-plaintext highlighter-rouge">upper_bound</code>.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">items</span><span class="p">;</span>

<span class="n">items</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="n">items</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
<span class="n">items</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">6</span><span class="p">);</span>
<span class="n">items</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">8</span><span class="p">);</span>

<span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">items</span><span class="p">.</span><span class="n">upper_bound</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">it</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="c1">// 6</span>
</code></pre></div></div>

<p>Java has similar data structures <code class="language-plaintext highlighter-rouge">TreeSet</code> and <code class="language-plaintext highlighter-rouge">TreeMap</code>. For example, the following code corresponds to the above C++ code.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">TreeSet</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">items</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeSet</span><span class="o">&lt;&gt;();</span>

<span class="n">items</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
<span class="n">items</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">3</span><span class="o">);</span>
<span class="n">items</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">6</span><span class="o">);</span>
<span class="n">items</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">8</span><span class="o">);</span>

<span class="kt">int</span> <span class="n">item</span> <span class="o">=</span> <span class="n">items</span><span class="o">.</span><span class="na">higher</span><span class="o">(</span><span class="mi">4</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">item</span><span class="o">);</span> <span class="c1">// 6</span>
</code></pre></div></div>

<p>JavaScript, similarly to Python, does not have a standard library implementation of binary search trees.</p>

</article>

      <footer>
        <img id="hy-logo" src="12.%20Binary%20search%20tree%20%E2%80%93%20Data%20Structures%20and%20Algorithms_files/hy_logo.svg">
        <style>
          .dark-theme #hy-logo {
            content: url("/spring-2025/assets/img/hy_logo_neg.svg");
          }
        </style>
      </footer>
    </main>
  

</body></html>