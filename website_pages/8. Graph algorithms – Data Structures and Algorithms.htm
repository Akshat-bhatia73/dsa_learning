<!DOCTYPE html>
<html lang="en" class="dark-theme"><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>8. Graph algorithms – 
      Data Structures and Algorithms
    </title>
    <link rel="stylesheet" href="8.%20Graph%20algorithms%20%E2%80%93%20Data%20Structures%20and%20Algorithms_files/fonts.css">
    <link rel="stylesheet" href="8.%20Graph%20algorithms%20%E2%80%93%20Data%20Structures%20and%20Algorithms_files/style.css">
    <script>
      let activeTheme = localStorage.getItem("theme");
      if (activeTheme === null) {
        activeTheme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light";
      }
      document.documentElement.classList.toggle(
        "dark-theme",
        activeTheme === "dark"
      );
      const hideOtherSectionMenus = 1;
    </script>
    <script src="8.%20Graph%20algorithms%20%E2%80%93%20Data%20Structures%20and%20Algorithms_files/navigation.js"></script>

    <link rel="stylesheet" href="8.%20Graph%20algorithms%20%E2%80%93%20Data%20Structures%20and%20Algorithms_files/katex.min.css" integrity="sha384-vKruj+a13U8yHIkAyGgK1J3ArTLzrFGBbBc0tDp4ad/EyewESeXE/Iv67Aj8gKZ0" crossorigin="anonymous">
    <script defer="defer" src="8.%20Graph%20algorithms%20%E2%80%93%20Data%20Structures%20and%20Algorithms_files/katex.min.js" integrity="sha384-PwRUT/YqbnEjkZO0zZxNqcxACrXe+j766U2amXcgMg5457rve2Y7I6ZJSm2A0mS4" crossorigin="anonymous"></script>
    <script defer="defer" src="8.%20Graph%20algorithms%20%E2%80%93%20Data%20Structures%20and%20Algorithms_files/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous" onload="renderMathInElement(document.body, { delimiter: [{left:'\\(',right:'\\)',display:false},{left:'\\[',right:'\\]',display:true}] });"></script>
  </head>
  <body class="">
    <div class="menu-background" id="menu-background"></div>
    <button class="menu" id="menu" aria-expanded="false" aria-controls="side" aria-label="Menu">
      <svg viewBox="0 0 5 5" width="25" height="25">
        <rect width="5" height="1"></rect>
        <rect width="5" height="1" y="2"></rect>
        <rect width="5" height="1" y="4"></rect>
      </svg>
    </button>
    <div class="side" id="side">
      <header>
        <button class="theme" id="theme" title="Switch theme">
          <svg viewBox="0 0 10 10" width="25" height="25">
            <circle cx="5" cy="5" r="2.4"></circle>
            <circle cx="5" cy="1" r="0.8"></circle>
            <circle cx="9" cy="5" r="0.8"></circle>
            <circle cx="5" cy="9" r="0.8"></circle>
            <circle cx="1" cy="5" r="0.8"></circle>
            <circle cx="2.17" cy="2.17" r="0.8"></circle>
            <circle cx="7.83" cy="2.17" r="0.8"></circle>
            <circle cx="2.17" cy="7.83" r="0.8"></circle>
            <circle cx="7.83" cy="7.83" r="0.8"></circle>
          </svg>
        </button>
        <a class="header" href="https://tira.mooc.fi/spring-2025/">
          <h1>Data Structures and Algorithms</h1><h2>spring 2025</h2></a>
      </header>
      <nav>
        
        <ul>
          
          
            <li data-url="/">
  <a href="https://tira.mooc.fi/spring-2025/">Course description</a>
  
  
</li>
          
            <li data-url="/exercises">
  <a href="https://tira.mooc.fi/spring-2025/exercises">Exercises and lecture videos</a>
  
  
</li>
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
        </ul>
        
        
          
          
          <ul>
            
              <li data-url="/chap01/">
  <a href="https://tira.mooc.fi/spring-2025/chap01/">1. Introduction</a>
  
  
</li>
            
              <li data-url="/chap02/">
  <a href="https://tira.mooc.fi/spring-2025/chap02/">2. List</a>
  
  
</li>
            
              <li data-url="/chap03/">
  <a href="https://tira.mooc.fi/spring-2025/chap03/">3. Efficient algorithms</a>
  
  
</li>
            
              <li data-url="/chap04/">
  <a href="https://tira.mooc.fi/spring-2025/chap04/">4. Hashing</a>
  
  
</li>
            
              <li data-url="/chap05/">
  <a href="https://tira.mooc.fi/spring-2025/chap05/">5. Sorting</a>
  
  
</li>
            
              <li data-url="/chap06/">
  <a href="https://tira.mooc.fi/spring-2025/chap06/">6. Own data structures</a>
  
  
</li>
            
              <li data-url="/chap07/">
  <a href="https://tira.mooc.fi/spring-2025/chap07/">7. Trees and recursion</a>
  
  
</li>
            
              <li data-url="/chap08/">
  <a href="https://tira.mooc.fi/spring-2025/chap08/" class="current">8. Graph algorithms</a>
  
  
    <ul>
      
        
          <li>
            <a href="https://tira.mooc.fi/spring-2025/chap08/#programming-with-graphs" data-anchor="programming-with-graphs">Programming with graphs</a>
          </li>
        
      
        
          <li>
            <a href="https://tira.mooc.fi/spring-2025/chap08/#depth-first-search" data-anchor="depth-first-search">Depth-first search</a>
          </li>
        
      
        
          <li>
            <a href="https://tira.mooc.fi/spring-2025/chap08/#components-and-connectivity" data-anchor="components-and-connectivity">Components and connectivity</a>
          </li>
        
      
        
          <li>
            <a href="https://tira.mooc.fi/spring-2025/chap08/#breadth-first-search" data-anchor="breadth-first-search">Breadth-first search</a>
          </li>
        
      
        
          <li>
            <a href="https://tira.mooc.fi/spring-2025/chap08/#shortest-paths-and-distances" data-anchor="shortest-paths-and-distances">Shortest paths and distances</a>
          </li>
        
      
        
          <li>
            <a href="https://tira.mooc.fi/spring-2025/chap08/#labyrinth-as-a-graph" data-anchor="labyrinth-as-a-graph">Labyrinth as a graph</a>
          </li>
        
      
    </ul>
  
</li>
            
          </ul>
          
          
        
          
          
          <ul>
            
              <li data-url="/chap09/">
  <a href="https://tira.mooc.fi/spring-2025/chap09/">9. Search problems</a>
  
  
</li>
            
              <li data-url="/chap10/">
  <a href="https://tira.mooc.fi/spring-2025/chap10/">10. Dynamic programming</a>
  
  
</li>
            
              <li data-url="/chap11/">
  <a href="https://tira.mooc.fi/spring-2025/chap11/">11. More data structures</a>
  
  
</li>
            
              <li data-url="/chap12/">
  <a href="https://tira.mooc.fi/spring-2025/chap12/">12. Binary search tree</a>
  
  
</li>
            
              <li data-url="/chap13/">
  <a href="https://tira.mooc.fi/spring-2025/chap13/">13. Directed graphs</a>
  
  
</li>
            
              <li data-url="/chap14/">
  <a href="https://tira.mooc.fi/spring-2025/chap14/">14. Shortest paths</a>
  
  
</li>
            
              <li data-url="/chap15/">
  <a href="https://tira.mooc.fi/spring-2025/chap15/">15. Components and spanning trees</a>
  
  
</li>
            
              <li data-url="/chap16/">
  <a href="https://tira.mooc.fi/spring-2025/chap16/">16. Maximum flow</a>
  
  
</li>
            
          </ul>
          
          
        
          
        
      </nav>
    </div>
    <main>
      <div class="awning" id="awning" aria-hidden="true">8. Graph algorithms</div>
      <article data-url="/chap08/">
  <h1 id="8-graph-algorithms">8. Graph algorithms</h1>

<p>A <em>graph</em> is a data structure that consists of <em>nodes</em> and <em>edges</em>. Each edge connects two nodes.</p>

<p>For example, the following graph has five nodes and seven edges:</p>

<p><img src="8.%20Graph%20algorithms%20%E2%80%93%20Data%20Structures%20and%20Algorithms_files/verkko1.png" alt=""></p>

<p>A <em>neighbor</em> of node is another node connected to it by an edge. In the example, the neighbors of the node 1 are the nodes 2, 3 and 4. The <em>degree</em> of a node is the number of its neighbors. For example, the degree of the node 1 is 3, because it has 3 neighbors.</p>

<p>A <em>path</em> between two nodes is a route along the edges of the graph. Here are some of the possible paths from the node 1 to the node 5:</p>

<ul>
  <li>1 → 2 → 5</li>
  <li>1 → 4 → 5</li>
  <li>1 → 3 → 4 → 5</li>
  <li>1 → 3 → 4 → 2 → 5</li>
</ul>

<p>Examples of applications of graphs:</p>

<ul>
  <li>Road network: The nodes are cities and the edges are roads. A path between two nodes is a route between two cities.</li>
  <li>Contact network: The nodes are people and the edges are contacts. A path between two nodes describes how people know each other.</li>
  <li>Communication network: The nodes are computers and the edges are 
connections. A path between two nodes describes how data can be 
transmitted.</li>
</ul>

<h2 id="programming-with-graphs">Programming with graphs</h2>

<p>A common way to represent a graph in programming is to have an <em>adjacency list</em> for each node. The adjacency list of a node <span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span></span> contains all nodes connected to <span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span></span> by an edge.</p>

<p>In Python, we can store a graph using a dictionary, where the keys 
are nodes and the values are adjacency lists. The example graph can be 
stored as follows:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">graph</span> <span class="o">=</span> <span class="p">{</span>
    <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>
    <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span>
    <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>
    <span class="mi">4</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span>
    <span class="mi">5</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="p">}</span>
</code></pre></div></div>
<p>It is often useful to define a class for graphs with a method for adding edges. The class can be implemented as follows:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Graph</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodes</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">nodes</span> <span class="o">=</span> <span class="n">nodes</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">graph</span> <span class="o">=</span> <span class="p">{</span><span class="n">node</span><span class="p">:</span> <span class="p">[]</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">}</span>
        
    <span class="k">def</span> <span class="nf">add_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">graph</span><span class="p">[</span><span class="n">a</span><span class="p">].</span><span class="n">append</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">graph</span><span class="p">[</span><span class="n">b</span><span class="p">].</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
</code></pre></div></div>

<p>Here the constructor gets a list <code class="language-plaintext highlighter-rouge">nodes</code> as a parameter containing the nodes of the graph. It then creates a dictionary <code class="language-plaintext highlighter-rouge">graph</code> that stores the adjacency lists. Initially, all adjacency lists are empty, and the method <code class="language-plaintext highlighter-rouge">add_edge</code> can be used for adding an edge between the nodes <code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">b</code>.</p>

<p>Now the example graph can be created as follows:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>

<span class="n">g</span><span class="p">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">g</span><span class="p">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">g</span><span class="p">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="n">g</span><span class="p">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="n">g</span><span class="p">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="n">g</span><span class="p">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="n">g</span><span class="p">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="depth-first-search">Depth-first search</h2>

<p><em>Depth-first search</em> or <em>DFS</em> is a technique for 
iterating through all nodes of a graph that can be reached from a given 
initial node by following edges. Depth-first search can be implemented 
using recursion given the adjacency lists.</p>

<p>The following code implements depth-first search:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">DFS</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodes</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">nodes</span> <span class="o">=</span> <span class="n">nodes</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">graph</span> <span class="o">=</span> <span class="p">{</span><span class="n">node</span><span class="p">:</span> <span class="p">[]</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">}</span>
        
    <span class="k">def</span> <span class="nf">add_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">graph</span><span class="p">[</span><span class="n">a</span><span class="p">].</span><span class="n">append</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">graph</span><span class="p">[</span><span class="n">b</span><span class="p">].</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        
    <span class="k">def</span> <span class="nf">visit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">.</span><span class="n">visited</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">visited</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">next_node</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">.</span><span class="n">graph</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">visit</span><span class="p">(</span><span class="n">next_node</span><span class="p">)</span>
        
    <span class="k">def</span> <span class="nf">search</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_node</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">visit</span><span class="p">(</span><span class="n">start_node</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">visited</span>
</code></pre></div></div>

<p>The method <code class="language-plaintext highlighter-rouge">search</code> performs a depth-first search starting from the node <code class="language-plaintext highlighter-rouge">start_node</code> and returns the nodes found. The method first creates a set <code class="language-plaintext highlighter-rouge">visited</code> that contains the nodes found during the search so far. Then the method calls the recursive method <code class="language-plaintext highlighter-rouge">visit</code> that performs the search.</p>

<p>The method <code class="language-plaintext highlighter-rouge">visit</code>
 is given a node to be visited as a parameter. If the node has already 
been visited, the method exits. Otherwise, the node is added to the set <code class="language-plaintext highlighter-rouge">visited</code>, and then the method goes through the adjacency list of the node and calls itself for each of the neighbors of the node.</p>

<p>The following code illutrates the operation of a depth-first search:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">d</span> <span class="o">=</span> <span class="n">DFS</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>

<span class="n">d</span><span class="p">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">d</span><span class="p">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">d</span><span class="p">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="n">d</span><span class="p">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="n">d</span><span class="p">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="n">d</span><span class="p">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="n">d</span><span class="p">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="n">d</span><span class="p">.</span><span class="n">search</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
</code></pre></div></div>

<p>The code prints out:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">}</span>
</code></pre></div></div>

<p>This means that the nodes 1, 2, 3, 4, and 5 were visited during the 
depth-first first starting from the node 1, in other words, all nodes of
 the graph are reachable from the node 1.</p>

<h2 id="components-and-connectivity">Components and connectivity</h2>

<p>A <em>component</em> of a graph contains nodes that are reachable 
from each other using the edges of the graph. For example, the following
 graph has three components: <span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>3</mn><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{1,2,3\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">{</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord">3</span><span class="mclose">}</span></span></span></span></span>, <span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mn>4</mn><mo separator="true">,</mo><mn>5</mn><mo separator="true">,</mo><mn>6</mn><mo separator="true">,</mo><mn>7</mn><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{4,5,6,7\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">{</span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord">7</span><span class="mclose">}</span></span></span></span></span> ja <span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mn>8</mn><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{8\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">{</span><span class="mord">8</span><span class="mclose">}</span></span></span></span></span>.</p>

<p><img src="8.%20Graph%20algorithms%20%E2%80%93%20Data%20Structures%20and%20Algorithms_files/verkko2.png" alt=""></p>

<p>A graph is <em>connected</em> if it has exactly one component, i.e., 
if there is a path between any two nodes. For example, the following 
graph is connected, since its only component is <span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>4</mn><mo separator="true">,</mo><mn>5</mn><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{1,2,3,4,5\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">{</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord">5</span><span class="mclose">}</span></span></span></span></span>.</p>

<p><img src="8.%20Graph%20algorithms%20%E2%80%93%20Data%20Structures%20and%20Algorithms_files/verkko1.png" alt=""></p>

<p>For example in a road network, if two cities are in the same 
component, one can travel between the cities using roads. If a road 
network is connected, any city can be reached from any other city using 
roads.</p>

<p>Using depth-first search we can compute the components of a graph by 
iterating through all nodes and starting a new search whenever we 
encounter a node that is not yet in any component. The following class <code class="language-plaintext highlighter-rouge">Components</code> implements this search:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Components</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodes</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">nodes</span> <span class="o">=</span> <span class="n">nodes</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">graph</span> <span class="o">=</span> <span class="p">{</span><span class="n">node</span><span class="p">:</span> <span class="p">[]</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">}</span>
        
    <span class="k">def</span> <span class="nf">add_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">graph</span><span class="p">[</span><span class="n">a</span><span class="p">].</span><span class="n">append</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">graph</span><span class="p">[</span><span class="n">b</span><span class="p">].</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        
    <span class="k">def</span> <span class="nf">visit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">.</span><span class="n">components</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">components</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">counter</span>

        <span class="k">for</span> <span class="n">next_node</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">.</span><span class="n">graph</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">visit</span><span class="p">(</span><span class="n">next_node</span><span class="p">)</span>
        
    <span class="k">def</span> <span class="nf">find_components</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">components</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">.</span><span class="n">nodes</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">.</span><span class="n">components</span><span class="p">:</span>
                <span class="bp">self</span><span class="p">.</span><span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="bp">self</span><span class="p">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
                
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">components</span>
</code></pre></div></div>

<p>The variable <code class="language-plaintext highlighter-rouge">counter</code>
 stores the number of components. Whenever we encounter a node that does
 not belong to any of the existing components, the variable is 
incremented by one, which correspond to creating a new component. The 
new component is initially empty and is then filled using a depth-first 
search.  The dictionary <code class="language-plaintext highlighter-rouge">components</code> stores the component of each node visited so far. The current value of the variable <code class="language-plaintext highlighter-rouge">counter</code> is used as the identifier of the component during the depth-first search.</p>

<p>The class can be used as follows:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">c</span> <span class="o">=</span> <span class="n">Components</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>

<span class="n">c</span><span class="p">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">c</span><span class="p">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="n">c</span><span class="p">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="n">c</span><span class="p">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">find_components</span><span class="p">())</span> <span class="c1"># {1: 1, 2: 1, 3: 2, 4: 2, 5: 2}
</span></code></pre></div></div>

<p>In this case, the graph has two components. The first component is <span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{1,2\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">{</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord">2</span><span class="mclose">}</span></span></span></span></span> and the second component is <span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mn>3</mn><mo separator="true">,</mo><mn>4</mn><mo separator="true">,</mo><mn>5</mn><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{3,4,5\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">{</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord">5</span><span class="mclose">}</span></span></span></span></span>.</p>

<h2 id="breadth-first-search">Breadth-first search</h2>

<p><em>Breadth-first search</em> or <em>BFS</em> is another technique 
for iterating through the nodes a graph. Similarly to depth-first 
search, breadth-first search starts at a given node and visits all nodes
 that are reachable from the start node using edges of the graph. The 
difference between the two techniques is the order in which the nodes 
are visited.</p>

<p>Breadth-first search can be implemented as follows:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">BFS</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodes</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">nodes</span> <span class="o">=</span> <span class="n">nodes</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">graph</span> <span class="o">=</span> <span class="p">{</span><span class="n">node</span><span class="p">:</span> <span class="p">[]</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">}</span>

    <span class="k">def</span> <span class="nf">add_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">graph</span><span class="p">[</span><span class="n">a</span><span class="p">].</span><span class="n">append</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">graph</span><span class="p">[</span><span class="n">b</span><span class="p">].</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">search</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_node</span><span class="p">):</span>
        <span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="n">queue</span> <span class="o">=</span> <span class="p">[</span><span class="n">start_node</span><span class="p">]</span>
        <span class="n">visited</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">start_node</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">queue</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">next_node</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">.</span><span class="n">graph</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">next_node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
                    <span class="n">queue</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">next_node</span><span class="p">)</span>
                    <span class="n">visited</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">next_node</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">visited</span>
</code></pre></div></div>

<p>The idea is to create a list <code class="language-plaintext highlighter-rouge">queue</code> that contains the nodes to be processed. Initially, the list <code class="language-plaintext highlighter-rouge">queue</code>
 contains the start node. In each step of the main loop, the search 
takes the next node from the queue and goes through the adjacency list 
of the node. Any node on the adjacency list that has not been visited 
yet is added to the queue.</p>

<p>The following code illustrates depth-first search:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">b</span> <span class="o">=</span> <span class="n">BFS</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>

<span class="n">b</span><span class="p">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">b</span><span class="p">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">b</span><span class="p">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="n">b</span><span class="p">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="n">b</span><span class="p">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="n">b</span><span class="p">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="n">b</span><span class="p">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="n">search</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
</code></pre></div></div>

<p>The code prints out:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{1, 2, 3, 4, 5}
</code></pre></div></div>

<h2 id="shortest-paths-and-distances">Shortest paths and distances</h2>

<p>The <em>shortest path</em> between two nodes in a graph is a path connecting the two nodes with the smallest number of edges. The <em>distance</em> of two nodes is the length of the shortest path between them.</p>

<p>For example, in the following graph the shortest path from the node 1
 to the node 5 goes from the node 1 to the node 4 and then from the node
 4 to the node 5. Since the shortest path has 2 edges, the distance from
 the node 1 to the node 5 is 2.</p>

<p><img src="8.%20Graph%20algorithms%20%E2%80%93%20Data%20Structures%20and%20Algorithms_files/verkko1.png" alt=""></p>

<p>A feature of breadth-first search is that it visits nodes in the 
order of their distance from the start node. Thus we can use 
breadth-first search to determine the distance of each node to the start
 node, and to find a shortest path between two nodes.</p>

<p>Let us consider computing distances first. The following class 
computes the distance from the start node to all nodes of the graph:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Distances</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodes</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">nodes</span> <span class="o">=</span> <span class="n">nodes</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">graph</span> <span class="o">=</span> <span class="p">{</span><span class="n">node</span><span class="p">:</span> <span class="p">[]</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">}</span>

    <span class="k">def</span> <span class="nf">add_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">graph</span><span class="p">[</span><span class="n">a</span><span class="p">].</span><span class="n">append</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">graph</span><span class="p">[</span><span class="n">b</span><span class="p">].</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">find_distances</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_node</span><span class="p">):</span>
        <span class="n">distances</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="n">queue</span> <span class="o">=</span> <span class="p">[</span><span class="n">start_node</span><span class="p">]</span>
        <span class="n">distances</span><span class="p">[</span><span class="n">start_node</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">queue</span><span class="p">:</span>
            <span class="n">distance</span> <span class="o">=</span> <span class="n">distances</span><span class="p">[</span><span class="n">node</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">next_node</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">.</span><span class="n">graph</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">next_node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">distances</span><span class="p">:</span>
                    <span class="n">queue</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">next_node</span><span class="p">)</span>
                    <span class="n">distances</span><span class="p">[</span><span class="n">next_node</span><span class="p">]</span> <span class="o">=</span> <span class="n">distance</span> <span class="o">+</span> <span class="mi">1</span>
                    
        <span class="k">return</span> <span class="n">distances</span>
</code></pre></div></div>

<p>The code is otherwise the same as the earlier breadth-first search, but now the set <code class="language-plaintext highlighter-rouge">visited</code> has been replaced by the dictionary <code class="language-plaintext highlighter-rouge">distances</code>
 that stores the discovered distances. When we encounter a node whose 
distance is not known yet, its distance becomes one bigger than the 
distance of the node through which it was reached.</p>

<p>The class can be used as follows:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">d</span> <span class="o">=</span> <span class="n">Distances</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>

<span class="n">d</span><span class="p">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">d</span><span class="p">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">d</span><span class="p">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="n">d</span><span class="p">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="n">d</span><span class="p">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="n">d</span><span class="p">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="n">d</span><span class="p">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="n">d</span><span class="p">.</span><span class="n">find_distances</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span> <span class="c1"># {1: 0, 2: 1, 3: 1, 4: 1, 5: 2}
</span></code></pre></div></div>

<p>Here we computed the distance from the node 1 to all nodes of the graph:</p>

<ul>
  <li>The distance to the node 1 is 0.</li>
  <li>The distance to the node 2 is 1.</li>
  <li>The distance to the node 3 is 1.</li>
  <li>The distance to the node 4 is 1.</li>
  <li>The distance to the node 5 is 2.</li>
</ul>

<p>Using breadth-first search we can also implement a class that finds a shortest path between two nodes:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">ShortestPaths</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodes</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">nodes</span> <span class="o">=</span> <span class="n">nodes</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">graph</span> <span class="o">=</span> <span class="p">{</span><span class="n">node</span><span class="p">:</span> <span class="p">[]</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">}</span>

    <span class="k">def</span> <span class="nf">add_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">graph</span><span class="p">[</span><span class="n">a</span><span class="p">].</span><span class="n">append</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">graph</span><span class="p">[</span><span class="n">b</span><span class="p">].</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">find_path</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_node</span><span class="p">,</span> <span class="n">end_node</span><span class="p">):</span>
        <span class="n">distances</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">previous</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="n">queue</span> <span class="o">=</span> <span class="p">[</span><span class="n">start_node</span><span class="p">]</span>
        <span class="n">distances</span><span class="p">[</span><span class="n">start_node</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">previous</span><span class="p">[</span><span class="n">start_node</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">queue</span><span class="p">:</span>
            <span class="n">distance</span> <span class="o">=</span> <span class="n">distances</span><span class="p">[</span><span class="n">node</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">next_node</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">.</span><span class="n">graph</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">next_node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">distances</span><span class="p">:</span>
                    <span class="n">queue</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">next_node</span><span class="p">)</span>
                    <span class="n">distances</span><span class="p">[</span><span class="n">next_node</span><span class="p">]</span> <span class="o">=</span> <span class="n">distance</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="n">previous</span><span class="p">[</span><span class="n">next_node</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span>
                
        <span class="k">if</span> <span class="n">end_node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">distances</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>
                
        <span class="n">node</span> <span class="o">=</span> <span class="n">end_node</span>
        <span class="n">path</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="n">node</span><span class="p">:</span>
            <span class="n">path</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">previous</span><span class="p">[</span><span class="n">node</span><span class="p">]</span>

        <span class="n">path</span><span class="p">.</span><span class="n">reverse</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">path</span>
</code></pre></div></div>

<p>The method <code class="language-plaintext highlighter-rouge">find_path</code> gets the nodes <code class="language-plaintext highlighter-rouge">start_node</code> and <code class="language-plaintext highlighter-rouge">end_node</code> as parameters and finds the shortest path between these nodes.</p>

<p>The dictionary <code class="language-plaintext highlighter-rouge">distances</code> stores distances to the start node as before. In addition, the dictionary <code class="language-plaintext highlighter-rouge">previous</code>
 stores for each node the preceding node on the shortest path, i.e., the
 node through which it was first reached. Using the dictionary <code class="language-plaintext highlighter-rouge">previous</code>, we can trace back the shortest path from the end node back to the start node. The path is then reversed before returning it.</p>

<p>The following code illustrates the use of the class:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">s</span> <span class="o">=</span> <span class="n">ShortestPaths</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>

<span class="n">s</span><span class="p">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">s</span><span class="p">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">s</span><span class="p">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="n">s</span><span class="p">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="n">s</span><span class="p">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="n">s</span><span class="p">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="n">s</span><span class="p">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">find_path</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span> <span class="c1"># [2, 4]
</span><span class="k">print</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">find_path</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span> <span class="c1"># [1, 2, 5]
</span><span class="k">print</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">find_path</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="c1"># [5, 2, 1]
</span></code></pre></div></div>

<h2 id="labyrinth-as-a-graph">Labyrinth as a graph</h2>

<p>Consider the following labyrinth, where the white squares are floor and the black squares are wall:</p>

<p><img src="8.%20Graph%20algorithms%20%E2%80%93%20Data%20Structures%20and%20Algorithms_files/laby.png" alt=""></p>

<p>We can use depth- or breadth-first search to find routes in the 
labyrinth. We can use graph nodes to represent the floor squares and 
edges to tell which squares are adjacent in the labyrinth.</p>

<p>We could build a graph based on the description of the labyrinth, but
 we can actually use the labyrinth itself as a graph. The following code
 shows how we can explore the labyrinth using depth-first search:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">explore</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">grid</span><span class="p">[</span><span class="n">y</span><span class="p">][</span><span class="n">x</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span>

    <span class="k">print</span><span class="p">(</span><span class="s">"visit"</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="n">grid</span><span class="p">[</span><span class="n">y</span><span class="p">][</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>

    <span class="n">explore</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">y</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="n">explore</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">y</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="n">explore</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">explore</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

<span class="n">grid</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]]</span>

<span class="n">explore</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">grid</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
</code></pre></div></div>

<p>The labyrinth is given as a two-dimensional list, where 0 means a floor square and 1 means a wall square. The function <code class="language-plaintext highlighter-rouge">explore</code> performs a depth-first search in the labyrinth so that the visited squares are marked with the value 2.</p>

<p>The function <code class="language-plaintext highlighter-rouge">explore</code>
 is given the coordinates of a square and it first checks the number in 
the square. If the number is not 0, the function exits, because then the
 square is either a wall square or a floor square that has been visited 
already. If the square is 0, the function marks it visited with the 
number 2. Then the function continues with recursive calls for the 
adjacent squares above, below, left and right.</p>

<p>Executing the code produces the following output:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>visit 1 1
visit 2 1
visit 3 1
visit 4 1
visit 4 2
visit 4 3
visit 4 4
visit 3 4
visit 3 5
visit 3 6
visit 2 6
visit 1 6
visit 1 5
visit 1 4
visit 1 3
visit 2 3
visit 1 2
visit 4 6
[1, 1, 1, 1, 1, 1, 1, 1]
[1, 2, 2, 2, 2, 2, 2, 1]
[1, 2, 1, 2, 1, 1, 2, 1]
[1, 2, 1, 1, 2, 2, 2, 1]
[1, 2, 2, 2, 2, 1, 2, 1]
[1, 1, 1, 1, 1, 1, 1, 1]
</code></pre></div></div>

</article>

      <footer>
        <img id="hy-logo" src="8.%20Graph%20algorithms%20%E2%80%93%20Data%20Structures%20and%20Algorithms_files/hy_logo.svg">
        <style>
          .dark-theme #hy-logo {
            content: url("/spring-2025/assets/img/hy_logo_neg.svg");
          }
        </style>
      </footer>
    </main>
  

</body></html>